# Frontend Implementation Guide: URL Dumps Explorer (/url-dumps)

## Project Context

You're implementing Issue #3 for the `auto_pricing_ui` project - a page to explore and analyze competitor URL dump files generated by Jose Maria's discovery system. These JSON files contain the competitor URLs that feed into our pricing analysis pipeline, stored in S3 at `auto.pricing/competitor-urls/`.

The frontend is already set up with Next.js 15, TypeScript, Tailwind CSS, and shadcn/ui components. The backend endpoints are fully implemented and ready to use. Your task is to build an intuitive explorer interface that helps users understand what competitor data is being discovered and fed into the pipeline.

## Understanding URL Dumps

URL dumps are the first stage of our data pipeline. Jose Maria's system runs daily at 3:00 AM UTC, discovering competitor storage facility URLs near our ModStorage locations. Each dump is a snapshot of discovered competitors at that moment, containing URLs, addresses, and confidence scores. These dumps directly determine what gets scraped in the A1 stage and ultimately processed into pricing data.

Each dump file follows the naming pattern `YYYY-MM-DD-HHMM.json` and contains an array of competitor entries with fields like location ID, competitor name, address, Google Maps URL, pricing page URL, confidence score, and discovery timestamp. Understanding these dumps helps debug why certain competitors might be missing from the final pricing data.

## Current Frontend Structure

Before starting, review these existing files in the `auto_pricing_ui` repository to understand established patterns:

The API client foundation is in `lib/api/client.ts`. Look at the `fetchWithError` helper (lines 13-22) which handles all API calls with proper error handling. The `ApiError` class preserves HTTP status codes for appropriate error handling. All your API calls should follow this pattern.

The UI component library is in `components/ui/`. You'll likely use `button.tsx` for action buttons, and potentially `badge.tsx` for confidence score indicators. Check if there are existing table components or if you need to build one. The project uses Tailwind for styling with a consistent color scheme defined in `tailwind.config.ts`.

Environment configuration in `.env` sets `NEXT_PUBLIC_API_URL`. During development this points to `http://localhost:8000`, in production to `https://18.189.253.176.sslip.io`. The API client automatically uses this variable.

## Backend Endpoints Ready for Use

The backend team has implemented three endpoints in `/Users/alber/Repos/AUTO_ANALYST/api/routes/competitors/competitor_urls.py`:

**GET /competitors/competitor-urls** (lines 50-96)
Returns a list of available URL dumps with summaries. Query parameter `limit` (default 30) controls how many dumps to return. Response includes timestamp, file key, total URLs count, creation date, and file size for each dump.

**GET /competitors/competitor-urls/{timestamp}** (lines 99-145)
Gets detailed information about a specific dump. The timestamp parameter should be in YYYY-MM-DD-HHMM format. Returns complete dump data including all URLs, location summaries, and competitor summaries.

**GET /competitors/competitor-urls/latest/detail** (lines 148-160)
Convenience endpoint that returns the most recent dump with full details. Returns null if no dumps exist. Useful for showing "latest update" information in the header.

## Your Task: Build the URL Dumps Explorer

Create a comprehensive explorer interface at `/url-dumps` that allows users to browse historical URL dumps and analyze their contents. The page should make it easy to understand what competitor data is being discovered over time.

## API Integration

First, add the TypeScript types and API functions to the existing API client. In `lib/api/types.ts`, add:

```typescript
export interface URLDumpSummary {
  timestamp: string        // YYYY-MM-DD-HHMM format
  file_key: string        // S3 key like "auto.pricing/competitor-urls/2025-08-09-0310.json"
  total_urls: number      // Total competitor URLs in this dump
  created_at: string      // ISO timestamp when file was created
  size_bytes: number      // File size in bytes
}

export interface URLDumpEntry {
  modstorage_location: string    // Our location ID like "Austin-TX-001"
  competitor_name: string         // Brand like "Extra Space Storage"
  competitor_address: string      // Physical address
  maps_url: string               // Google Maps link
  final_pricing_url: string      // The pricing page we'll scrape
  confidence: number             // Discovery confidence 0-100
  timestamp: string              // When this was discovered
}

export interface URLDumpDetail {
  timestamp: string
  file_key: string
  total_urls: number
  created_at: string
  urls: URLDumpEntry[]                           // All URLs in the dump
  locations_summary: Record<string, number>      // URL count per location
  competitors_summary: Record<string, number>    // URL count per competitor
}
```

Then in `lib/api/client.ts`, add these functions following the existing pattern:

```typescript
export async function getURLDumps(limit = 30): Promise<URLDumpSummary[]> {
  const response = await fetchWithError(
    `${API_BASE_URL}/competitors/competitor-urls?limit=${limit}`
  )
  return response.json()
}

export async function getURLDumpDetail(timestamp: string): Promise<URLDumpDetail> {
  const response = await fetchWithError(
    `${API_BASE_URL}/competitors/competitor-urls/${timestamp}`
  )
  return response.json()
}

export async function getLatestURLDump(): Promise<URLDumpDetail | null> {
  const response = await fetchWithError(
    `${API_BASE_URL}/competitors/competitor-urls/latest/detail`
  )
  return response.json()
}
```

## Page Implementation

Create the main page at `app/url-dumps/page.tsx` as a client component. This page manages the state for the dumps list and selected dump details:

```typescript
'use client'

import { useState, useEffect } from 'react'
import { getURLDumps, getURLDumpDetail, getLatestURLDump } from '@/lib/api/client'
import type { URLDumpSummary, URLDumpDetail } from '@/lib/api/types'
// Import your components here

export default function URLDumpsPage() {
  const [dumps, setDumps] = useState<URLDumpSummary[]>([])
  const [selectedDump, setSelectedDump] = useState<URLDumpDetail | null>(null)
  const [latestDump, setLatestDump] = useState<URLDumpDetail | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Load initial data
  useEffect(() => {
    loadDumps()
  }, [])

  const loadDumps = async () => {
    try {
      setLoading(true)
      const [dumpsList, latest] = await Promise.all([
        getURLDumps(),
        getLatestURLDump()
      ])
      setDumps(dumpsList)
      setLatestDump(latest)
    } catch (err) {
      setError('Failed to load URL dumps')
      console.error(err)
    } finally {
      setLoading(false)
    }
  }

  // Handle viewing dump details
  const handleViewDump = async (timestamp: string) => {
    try {
      const detail = await getURLDumpDetail(timestamp)
      setSelectedDump(detail)
    } catch (err) {
      console.error('Failed to load dump details:', err)
    }
  }

  return (
    <div className="container mx-auto p-6">
      {/* Header section with latest dump info */}
      {/* Dumps list table */}
      {/* Detail modal/drawer when selectedDump is set */}
    </div>
  )
}
```

## Component Structure

Organize components under `components/url-dumps/` for maintainability:

**dumps-table.tsx** - Main table displaying the list of dumps
- Show columns: Timestamp, Total URLs, File Size, Created At, Actions
- Format timestamps to local timezone using `new Date(timestamp).toLocaleString()`
- Format file sizes using a helper like `formatBytes(size_bytes)`
- Sort by timestamp descending (newest first)
- "View" button triggers `handleViewDump(timestamp)`

**dump-detail-modal.tsx** - Modal or drawer showing dump details
- Header with dump timestamp and summary stats
- Two summary cards showing locations and competitors distribution
- Searchable/filterable table of all URLs
- Include local state for search term and filtered results

**confidence-badge.tsx** - Visual indicator for confidence scores
```typescript
export function ConfidenceBadge({ score }: { score: number }) {
  const color = score > 80 ? 'bg-green-500' : score > 50 ? 'bg-yellow-500' : 'bg-red-500'
  return (
    <span className={`px-2 py-1 rounded text-white text-sm ${color}`}>
      {score}%
    </span>
  )
}
```

**url-entry-row.tsx** - Table row component for individual URLs
- Display location, competitor, address, confidence
- Action buttons for "View on Maps" and "View Pricing"
- External links should open in new tabs: `target="_blank" rel="noopener noreferrer"`

## Search and Filter Implementation

Add search functionality to the detail view for finding specific URLs:

```typescript
const [searchTerm, setSearchTerm] = useState('')

const filteredUrls = selectedDump?.urls.filter(url => 
  url.modstorage_location.toLowerCase().includes(searchTerm.toLowerCase()) ||
  url.competitor_name.toLowerCase().includes(searchTerm.toLowerCase()) ||
  url.competitor_address.toLowerCase().includes(searchTerm.toLowerCase())
) || []
```

Consider adding filters for confidence ranges or specific locations/competitors using select dropdowns or checkboxes.

## Helper Functions

Create utility functions for common formatting needs:

```typescript
// Format bytes to human readable
export function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i]
}

// Format timestamp to readable date
export function formatTimestamp(timestamp: string): string {
  // Parse YYYY-MM-DD-HHMM format
  const match = timestamp.match(/(\d{4})-(\d{2})-(\d{2})-(\d{2})(\d{2})/)
  if (!match) return timestamp
  
  const [_, year, month, day, hour, minute] = match
  const date = new Date(`${year}-${month}-${day}T${hour}:${minute}:00Z`)
  return date.toLocaleString()
}

// Get relative time (e.g., "2 hours ago")
export function getRelativeTime(dateString: string): string {
  const date = new Date(dateString)
  const now = new Date()
  const seconds = Math.floor((now.getTime() - date.getTime()) / 1000)
  
  if (seconds < 60) return 'just now'
  if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes ago`
  if (seconds < 86400) return `${Math.floor(seconds / 3600)} hours ago`
  return `${Math.floor(seconds / 86400)} days ago`
}
```

## Loading and Error States

Implement proper loading states using skeletons or spinners:

```typescript
if (loading) {
  return (
    <div className="container mx-auto p-6">
      <div className="animate-pulse">
        <div className="h-8 bg-gray-200 rounded w-1/4 mb-4"></div>
        <div className="h-64 bg-gray-200 rounded"></div>
      </div>
    </div>
  )
}

if (error) {
  return (
    <div className="container mx-auto p-6">
      <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
        {error}
      </div>
    </div>
  )
}
```

## Responsive Design

Make the interface work well on mobile devices:

- On small screens, convert tables to stacked cards
- Use Tailwind's responsive utilities: `md:table-cell hidden`
- Ensure modals are full-screen on mobile
- Make buttons touch-friendly with adequate padding

## Performance Considerations

If URL lists are long (>100 items), consider implementing virtualization using a library like `react-window` or pagination. For the initial implementation, simple pagination might be sufficient:

```typescript
const ITEMS_PER_PAGE = 50
const [currentPage, setCurrentPage] = useState(0)

const paginatedUrls = filteredUrls.slice(
  currentPage * ITEMS_PER_PAGE,
  (currentPage + 1) * ITEMS_PER_PAGE
)
```

## Testing Your Implementation

Test these scenarios thoroughly:

1. **Initial Load**: Page displays list of dumps sorted by newest first
2. **Latest Info**: Header shows information from the most recent dump
3. **View Details**: Clicking "View" opens modal with correct dump data
4. **Search**: Filtering URLs by search term works correctly
5. **External Links**: Maps and pricing URLs open in new tabs
6. **Confidence Badges**: Colors match the confidence ranges
7. **Time Display**: Timestamps show in user's local timezone
8. **Empty State**: Appropriate message if no dumps exist
9. **Error Handling**: Network errors display user-friendly messages
10. **Mobile**: Layout adapts properly to small screens

## Debugging Tips

Use browser DevTools to monitor API calls:
- Network tab shows request/response details
- Console for error messages
- React DevTools to inspect component state

If the backend isn't available locally, you can temporarily mock the API responses:

```typescript
// Temporary mock for development
const mockDumps: URLDumpSummary[] = [
  {
    timestamp: "2025-08-09-0310",
    file_key: "auto.pricing/competitor-urls/2025-08-09-0310.json",
    total_urls: 42,
    created_at: "2025-08-09T03:10:00Z",
    size_bytes: 15234
  }
]
```

## Common Pitfalls to Avoid

1. **Timezone Confusion**: Remember backend timestamps are UTC. Always convert to local time for display
2. **Large Data Sets**: Don't try to render hundreds of URLs without pagination or virtualization
3. **State Management**: Keep modal/drawer state separate from data state
4. **Memory Leaks**: Clean up any intervals or subscriptions in useEffect return functions
5. **Error Boundaries**: Consider adding error boundaries for graceful failure handling

## Deployment Verification

After implementation:
1. Test locally with `npm run dev`
2. Build for production with `npm run build` to catch any build errors
3. Create a PR with your changes
4. After merge, GitHub Actions deploys automatically
5. Verify at `https://a5-cc.github.io/auto_pricing_ui/url-dumps`

## Next Steps and Future Enhancements

Once the basic explorer is working, consider these enhancements:
- Export functionality to download dump data as CSV
- Historical comparison to see how discoveries change over time
- Charts showing discovery trends (URLs per day, confidence distribution)
- Alerts for significant changes in discovery patterns
- Integration with the pipeline status page to show which dump was processed

## Questions or Issues?

The backend implementation is in `/Users/alber/Repos/AUTO_ANALYST/api/routes/competitors/competitor_urls.py` if you need to understand the API responses better.

The S3 structure is documented in `/Users/alber/Repos/AUTO_ANALYST/.docs/data-layer/schema/s3-bucket.yaml` lines 29-46 for understanding the data source.

## Final Notes

This URL Dumps Explorer is a critical debugging and monitoring tool for the pricing pipeline. It provides visibility into the very first stage of data acquisition - what competitors we're discovering. This helps answer questions like "Why don't we have pricing for competitor X?" or "When did we start tracking location Y?"

Focus on making the data easily explorable and searchable. Users should be able to quickly find specific competitors or locations and understand the discovery patterns over time. The confidence scores are particularly important as they indicate the reliability of the discovery process.

Good luck with the implementation! The existing codebase has solid patterns to follow, and the backend is fully ready to support your frontend work.